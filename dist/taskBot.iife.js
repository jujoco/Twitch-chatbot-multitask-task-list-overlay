var G = (h, p, k) => { if (!p.has(h)) throw TypeError("Cannot " + k); }; var l = (h, p, k) => (G(h, p, "read from private field"), k ? k.call(h) : p.get(h)), E = (h, p, k) => { if (p.has(h)) throw TypeError("Cannot add the same private member more than once"); p instanceof WeakSet ? p.add(h) : p.set(h, k); }, O = (h, p, k, U) => (G(h, p, "write to private field"), U ? U.call(h, k) : p.set(h, k), k); var S = (h, p, k) => (G(h, p, "access private method"), k); (function () {
   "use strict"; var D, K, I, N, B, L, $, v, m, A, b, q, _, F, z; let h, p, k = !1; function U() { const e = document.querySelector(".task-wrapper").clientHeight, t = document.querySelector(".task-container.primary"), s = t.scrollHeight, n = document.querySelector(".task-container.secondary"); if (s > e && !k) { n.style.display = "flex"; const r = configs.settings.scrollSpeed.toString(); let a = parseInt(r, 10), c = { duration: s / a * 1e3, iterations: 1, easing: "linear" }; const y = getComputedStyle(document.documentElement).getPropertyValue("--card-gap-between").slice(0, -2); let g = s + parseInt(y, 10), d = [{ transform: "translateY(0)" }, { transform: `translateY(-${g}px)` }], f = [{ transform: "translateY(0)" }, { transform: `translateY(-${g}px)` }]; h = t.animate(d, c), p = n.animate(f, c), k = !0, Z(); } else s <= e && (n.style.display = "none", Q()); } function Q() { h && h.cancel(), p && p.cancel(), k = !1; } function Z() { h && (h.addEventListener("finish", V), h.addEventListener("cancel", V)); } function V() { k = !1, U(); } function R(o, e) { o.innerText !== e && (o.style.opacity = "0", setTimeout(() => { o.textContent = e, o.style.opacity = "1"; }, 1e3)); } function X(o) { const e = document.querySelector(":root"); for (let [t, s] of Object.entries(o)) t.includes("FontFamily") && ee(s), e.style.setProperty(te(t), s); } function ee(o) { WebFont.load({ google: { families: [`${o}:100,400,700`] } }); } function te(o) { return `--${o.replace(/([A-Z])/g, "-$1").toLowerCase()}`; } class J { constructor(e, t) { this.username = this.validateUsername(e), this.userColor = (t == null ? void 0 : t.userColor) || "", this.tasks = []; } validateUsername(e) { if (typeof e != "string") throw new Error("Username must be of type string"); if (e = e.trim(), e.length === 0) throw new Error("Username invalid"); return e; } addTask(e) { return this.tasks.push(e), e; } editTask(e, t) { let s = this.getTask(e); return s ? (s.setDescription(t), s) : null; } completeTask(e) { let t = this.getTask(e); return t ? (t.setCompletionStatus(!0), t) : null; } deleteTask(e) { const t = [].concat(e).filter(n => this.validTaskIndex(n)), s = []; return this.tasks = this.tasks.filter((n, r) => t.includes(r) ? (s.push(n), !1) : !0), s; } removeCompletedTasks() { const e = []; return this.tasks = this.tasks.filter(t => t.isComplete() ? (e.push(t), !1) : !0), e; } getTask(e) { return this.validTaskIndex(e) ? this.tasks[e] : null; } getTasks() { return this.tasks; } validTaskIndex(e) { return !(typeof e != "number" || isNaN(e) || e < 0 || e >= this.tasks.length); } } class W { constructor(e) { E(this, D); this.description = this.validateDescription(e), this.id = S(this, D, K).call(this), this.completionStatus = !1; } validateDescription(e) { if (typeof e != "string") throw new Error("Task description must be of type string"); if (e = e.trim(), e.length === 0) throw new Error("Task description invalid"); return e; } setDescription(e) { this.description = this.validateDescription(e); } isComplete() { return this.completionStatus; } setCompletionStatus(e) { if (typeof e != "boolean") throw new Error("Completion status must be of type boolean"); this.completionStatus = e; } } D = new WeakSet, K = function () { const e = new Date, t = String(e.getDate()).padStart(2, "0"), s = String(e.getHours()).padStart(2, "0"), n = String(e.getMinutes()).padStart(2, "0"), r = String(e.getSeconds()).padStart(2, "0"), a = String(e.getMilliseconds()).padStart(3, "0"), i = Math.floor(Math.random() * 1e4); return `${t}${s}${n}${r}${a}${i}`; }; class se { constructor(e = "userList") { E(this, N); E(this, L); E(this, I, void 0); O(this, I, e), this.tasksCompleted = 0, this.totalTasks = 0, this.users = S(this, N, B).call(this); } getUser(e) { return this.users.find(t => t.username === e); } getAllUsers() { return this.users; } createUser(e, t) { if (this.getUser(e)) throw new Error(`${e} already exists`); const s = new J(e, t); return this.users.push(s), s; } addUserTasks(e, t) { const s = this.getUser(e); if (!s) throw new Error(`${e} does not exist`); const n = [].concat(t), r = []; return n.forEach(a => { r.push(s.addTask(new W(a))), this.totalTasks++; }), S(this, L, $).call(this), r; } editUserTask(e, t, s) { const n = this.getUser(e); if (!n) throw new Error(`${e} has no tasks`); const r = n.editTask(t, s); if (!r) throw new Error(`Task ${t} not found`); return S(this, L, $).call(this), r; } completeUserTasks(e, t) { const s = this.getUser(e); if (!s) throw new Error(`${e} has no tasks`); const r = [].concat(t).map(a => { const i = s.getTask(a); return i && !i.isComplete() && (i.setCompletionStatus(!0), this.tasksCompleted++), i; }); return S(this, L, $).call(this), r; } deleteUserTasks(e, t) { const s = this.getUser(e); if (!s) throw new Error(`${e} has no tasks`); const n = [].concat(t), r = s.deleteTask(n); return s.getTasks().length === 0 && this.deleteUser(e), this.decreaseTaskCount(r), S(this, L, $).call(this), r; } checkUserTasks(e, t = "incomplete") { const s = this.getUser(e); if (!s) throw new Error(`${e} has no tasks`); const n = new Map; return s.getTasks().forEach((r, a) => { t === "incomplete" && !r.isComplete() && n.set(a, r), t === "complete" && r.isComplete() && n.set(a, r); }), n; } clearUserList() { this.users = [], this.tasksCompleted = 0, this.totalTasks = 0, S(this, L, $).call(this); } clearDoneTasks() { let e = []; return this.users.forEach(t => { let s = t.removeCompletedTasks(); this.decreaseTaskCount(s), e = e.concat(s); }), S(this, L, $).call(this), e; } deleteUser(e) { const t = this.users.findIndex(r => r.username === e); if (t === -1) throw new Error(`${e} not found`); const s = this.users[t], n = this.users.splice(t, 1)[0]; return this.decreaseTaskCount(n.getTasks()), S(this, L, $).call(this), s; } decreaseTaskCount(e) { e.forEach(t => { t.isComplete() && this.tasksCompleted--, this.totalTasks--; }); } } I = new WeakMap, N = new WeakSet, B = function () { const e = []; let t = localStorage.getItem(l(this, I)); return t ? JSON.parse(t).forEach(s => { const n = new J(s.username, { userColor: s.userColor }); s.tasks.map(r => { const a = n.addTask(new W(r.description)); this.totalTasks++, r.completionStatus && (a.setCompletionStatus(r.completionStatus), this.tasksCompleted++); }), e.push(n); }) : localStorage.setItem(l(this, I), JSON.stringify(e)), e; }, L = new WeakSet, $ = function () { localStorage.setItem(l(this, I), JSON.stringify(this.users)); }; class re { constructor(e) { E(this, v, null); this.userList = new se(e), X(configs.styles); } render() { this.renderTaskList(), this.renderTaskHeader(); } renderTaskList() { if (this.userList.users.length === 0) return; const e = document.createDocumentFragment(); this.userList.getAllUsers().forEach(a => { const i = j(a), c = i.querySelector("ol"); a.tasks.forEach(y => { const g = document.createElement("li"); g.classList.add("task"), g.dataset.taskId = `${y.id}`, g.innerText = y.description, y.isComplete() && g.classList.add("done"), c.appendChild(g); }), e.appendChild(i); }); const t = e.cloneNode(!0), s = document.querySelector(".task-container.primary"); s.innerHTML = "", s.appendChild(t); const n = e.cloneNode(!0), r = document.querySelector(".task-container.secondary"); r.innerHTML = "", r.appendChild(n), U(); } renderTaskHeader() { this.renderTaskCount(); const { headerDisplay: e, headerText: t } = configs.settings; e.toLowerCase() === "timer" ? this.renderTimer() : e.toLowerCase() === "commands" ? this.renderCommandTips() : e.toLowerCase() === "text" && this.renderCustomText(t); } renderTaskCount() { let e = this.userList.tasksCompleted, t = this.userList.totalTasks; const s = document.querySelector(".task-count"); s.innerText = `${e}/${t}`; } renderTimer(e = 0) { l(this, v) && clearInterval(l(this, v)); const t = document.querySelector(".timer"); t.classList.remove("hidden"); const s = t.querySelector(".timer-title"), n = t.querySelector(".timer-countdown"); let r = e * 60; O(this, v, setInterval(() => { const i = Math.floor(r / 60).toString().padStart(2, "0"), c = (r % 60).toString().padStart(2, "0"); n.textContent = `${i}:${c}`, r === 0 ? (clearInterval(l(this, v)), n.textContent = "00:00", R(s, "Break")) : (R(s, "Focus"), r--); }, 1e3)); } renderCommandTips() { const e = ["!add", "!edit", "!done", "!remove", "!check", "!help"], t = document.querySelector(".command-tips"); t.classList.remove("hidden"); let s = 0; setInterval(() => { const n = t.querySelector(".command-code"); R(n, e[s]), s = (s + 1) % e.length; }, 6e3); } renderCustomText(e) { document.querySelector(".custom-header").classList.remove("hidden"), document.querySelector(".custom-text").textContent = e; } chatHandler(e, t, s, n, r) { t = `!${t.toLowerCase()}`; const { admin: a, user: i, settings: { languageCode: c, maxTasksPerUser: y, headerDisplay: g } } = configs; let d = "", f = ""; try { if (ne(n)) if (g.toLowerCase() === "timer" && a.commands.timer.includes(t) && n.broadcaster) { const u = parseInt(s, 10); if (isNaN(u) || u <= 0) throw new Error("Invalid timer duration"); return this.renderTimer(u), d = a.responseTo[c].timer, f = u, x(d, e, f); } else { if (a.commands.clearList.includes(t)) return this.userList.clearUserList(), this.clearListFromDOM(), d = a.responseTo[c].clearList, x(d, e, f); if (a.commands.clearDone.includes(t)) return this.userList.clearDoneTasks().forEach(({ id: C }) => { this.deleteTaskFromDOM(C); }), d = a.responseTo[c].clearDone, x(d, e, f); if (a.commands.clearUser.includes(t)) { const u = this.userList.deleteUser(s); return this.deleteUserFromDOM(u), f = u.username, d = a.responseTo[c].clearUser, x(d, e, f); } } if (i.commands.addTask.includes(t)) { if (s === "") throw new Error("Task description is empty"); let u = this.userList.getUser(e) || this.userList.createUser(e, { userColor: r.userColor }); const C = s.split(", "); u.getTasks().length + C.length > parseInt(y.toString(), 10) ? d = i.responseTo[c].maxTasksAdded : (this.userList.addUserTasks(e, C).forEach(w => { this.addTaskToDOM(u, w); }), f = s, d = i.responseTo[c].addTask); } else if (i.commands.editTask.includes(t)) { const u = s.search(new RegExp("(?<=\\d)\\s")); if (u === -1) throw new Error("Task number or description format is invalid"); const C = s.slice(0, u), T = s.slice(u + 1), w = this.userList.editUserTask(e, M(C), T); this.editTaskFromDOM(w), f = C, d = i.responseTo[c].editTask; } else if (i.commands.finishTask.includes(t)) { const u = s.split(",").reduce((T, w) => (M(w) >= 0 && T.push(M(w)), T), []); this.userList.completeUserTasks(e, u).forEach(({ id: T }) => { this.completeTaskFromDOM(T); }), f = s, d = i.responseTo[c].finishTask; } else if (i.commands.deleteTask.includes(t)) { if (s.toLowerCase() === "all") { const u = this.userList.deleteUser(e); this.deleteUserFromDOM(u), d = i.responseTo[c].deleteAll; } else { const u = s.split(",").reduce((T, w) => (M(w) >= 0 && T.push(M(w)), T), []); this.userList.deleteUserTasks(e, u).forEach(({ id: T }) => { this.deleteTaskFromDOM(T); }), d = i.responseTo[c].deleteTask; } f = s; } else if (i.commands.check.includes(t)) { const u = this.userList.checkUserTasks(e), C = []; for (let [T, w] of u) C.push(`${T + 1}. ${w.description}`); f = C.join(" | "), f === "" ? d = i.responseTo[c].noTaskFound : d = i.responseTo[c].check; } else if (i.commands.help.includes(t)) d = i.responseTo[c].help; else if (i.commands.additional.includes(t)) d = i.responseTo[c].additional; else throw new Error("command not found"); return x(d, e, f); } catch (u) { return x(i.responseTo[c].invalidCommand, e, u.message, !0); } } clearListFromDOM() { const e = document.querySelector(".task-container.primary"), t = document.querySelector(".task-container.secondary"); e.innerHTML = "", t.innerHTML = "", this.renderTaskCount(); } addTaskToDOM(e, t) { const s = document.querySelector(".task-container.primary"), n = document.querySelector(".task-container.secondary"); if (document.querySelectorAll(`[data-user="${e.username}"]`).length === 0) { const c = j(e), y = c.cloneNode(!0); s.appendChild(c), n.appendChild(y); } const a = document.createElement("li"); a.classList.add("task"), a.dataset.taskId = `${t.id}`, a.innerText = t.description; const i = a.cloneNode(!0); s.querySelector(`[data-user="${e.username}"] .tasks`).appendChild(a), n.querySelector(`[data-user="${e.username}"] .tasks`).appendChild(i), this.renderTaskCount(), U(); } editTaskFromDOM(e) { const t = document.querySelectorAll(`[data-task-id="${e.id}"]`); for (const s of t) s.innerText = e.description; } completeTaskFromDOM(e) { const t = document.querySelectorAll(`[data-task-id="${e}"]`); for (const s of t) s.classList.add("done"); this.renderTaskCount(); } deleteTaskFromDOM(e) { const t = document.querySelectorAll(`[data-task-id="${e}"]`); for (const s of t) s.parentElement.children.length === 1 ? s.parentElement.parentElement.remove() : s.remove(); this.renderTaskCount(); } deleteUserFromDOM(e) { const { username: t, tasks: s } = e, n = document.querySelectorAll(`[data-user="${t}"]`); for (let r of n) r.remove(); this.renderTaskCount(); } } v = new WeakMap; function x(o, e, t, s = !1) { return { message: o.replace("{user}", e).replace("{message}", t), error: s }; } function ne(o) { return o.broadcaster || o.mod; } function M(o) { return parseInt(o, 10) - 1; } function j({ username: o, userColor: e }) { const t = document.createElement("div"); t.classList.add("card"), t.dataset.user = o; const s = document.createElement("div"); s.classList.add("username"), s.innerText = o, s.style.color = configs.settings.showUsernameColor ? e : "", t.appendChild(s); const n = document.createElement("ol"); return n.classList.add("tasks"), t.appendChild(n), t; } function oe(o) { const e = { command: null, parameters: null, source: null, tags: null }; let t = 0, s = null, n = null, r = null, a = null; if (o[t] === "@") { let c = o.indexOf(" "); s = o.slice(1, c), t = c + 1; } if (o[t] === ":") { t += 1; let c = o.indexOf(" ", t); n = o.slice(t, c), t = c + 1; } let i = o.indexOf(":", t); return i === -1 && (i = o.length), r = o.slice(t, i).trim(), i !== o.length && (t = i + 1, a = o.slice(t)), e.command = ae(r), e.command === null ? null : (s !== null && (e.tags = ie(s)), e.source = ce(n), e.parameters = a, a && a[0] === "!" && (e.command = le(a, e.command)), e); } function ae(o) { let e = null; const t = o.split(" "); switch (t[0]) { case "JOIN": case "PART": case "NOTICE": case "CLEARCHAT": case "HOSTTARGET": case "PRIVMSG": e = { command: t[0], channel: t[1] }; break; case "PING": e = { command: t[0] }; break; case "CAP": e = { command: t[0], isCapRequestEnabled: t[2] === "ACK" }; break; case "GLOBALUSERSTATE": e = { command: t[0] }; break; case "USERSTATE": case "ROOMSTATE": e = { command: t[0], channel: t[1] }; break; case "RECONNECT": e = { command: t[0] }; break; case "421": return console.error(`Unsupported IRC command: ${t[2]}`), null; case "001": e = { command: t[0] }; break; case "002": case "003": case "004": case "353": case "366": case "372": case "375": case "376": return null; default: return console.log(`Unexpected command: ${t[0]}`), null; }return e; } function ie(o) { const e = { "client-nonce": null, flags: null }; let t = {}; return o.split(";").forEach(n => { let r = n.split("="), a = r[1] === "" ? null : r[1]; switch (r[0]) { case "badges": case "badge-info": if (a) { let c = {}; a.split(",").forEach(g => { let d = g.split("/"); c[d[0]] = d[1]; }), t[r[0]] = c; } else t[r[0]] = null; break; case "emotes": if (a) { let c = {}; a.split("/").forEach(g => { let d = g.split(":"), f = []; d[1].split(",").forEach(C => { let T = C.split("-"); f.push({ startPosition: T[0], endPosition: T[1] }); }), c[d[0]] = f; }), t[r[0]] = c; } else t[r[0]] = null; break; case "emote-sets": let i = a.split(","); t[r[0]] = i; break; default: e.hasOwnProperty(r[0]) || (t[r[0]] = a); } }), t; } function ce(o) { if (o == null) return null; { let e = o.split("!"); return { nick: e.length == 2 ? e[0] : null, host: e.length == 2 ? e[1] : e[0] }; } } function le(o, e) { let s = o.slice(0 + 1).trim(), n = s.indexOf(" "); return n === -1 ? (e.botCommand = s.slice(0), e.botCommandParams = "") : (e.botCommand = s.slice(0, n), e.botCommandParams = s.slice(n).trim()), e; } class de { constructor() { this.events = new Map; } on(e, t) { this.events.has(e) || this.events.set(e, []), this.events.get(e).push(t); } emit(e, ...t) { this.events.has(e) && this.events.get(e).forEach(s => s(...t)); } off(e, t) { if (this.events.has(e)) { const s = this.events.get(e), n = s.indexOf(t); n !== -1 && (s.splice(n, 1), s.length === 0 && this.events.delete(e)); } } once(e, t) { const s = (...n) => { t(...n), this.off(e, s); }; this.on(e, s); } } class ue extends de { constructor({ username: t, authToken: s, channel: n }) { super(); E(this, q); E(this, F); E(this, m, null); E(this, A, { 0: "CONNECTING", 1: "OPEN", 2: "CLOSING", 3: "CLOSED" }); E(this, b, 0); this.username = t.toLowerCase(), this.channel = `#${n.toLowerCase()}`, this.authToken = s; } connect(t = "ws://irc-ws.chat.twitch.tv:80") { O(this, m, new WebSocket(t)), l(this, m).onopen = () => { console.log("Authenticating with Twitch IRC server..."), l(this, m).send("CAP REQ :twitch.tv/tags twitch.tv/commands"), l(this, m).send(`PASS ${this.authToken}`), l(this, m).send(`NICK ${this.username}`); }, l(this, m).onerror = s => (console.error("An error occurred while attempting to establish a WebSocket connect", s), s), l(this, m).onmessage = s => { S(this, q, _).call(this, s.data); }, l(this, m).onclose = s => { switch (s.code) { case 1e3: console.log("Connection closed normally."); break; case 1006: console.error(`Connection dropped. Reconnecting in ${l(this, b)} milliseconds...`); let n = l(this, b); setTimeout(() => { this.connect(); }, n), O(this, b, l(this, b) === 0 ? 1e3 : l(this, b) * 2); break; case 1012: console.log("Switching  servers..."), this.connect(); break; default: console.error(`Unhandled code: ${s.code}. Reason: ${s.reason}`); } }; } say(t, s) { if (l(this, m).readyState === WebSocket.OPEN) { const r = [s ? `@reply-parent-msg-id=${s}` : "", "PRIVMSG", this.channel, `:${t}`].join(" ").trim(); l(this, m).send(r); } else console.error("Connection is not open"); } disconnect(t = 1e3, s = "") { S(this, F, z).call(this) === "OPEN" && l(this, m).close(t, s); } } m = new WeakMap, A = new WeakMap, b = new WeakMap, q = new WeakSet, _ = function (t) {
      t.trim().split(`\r
`).forEach(n => { const r = oe(n); if (r) switch (r.command.command) { case "PRIVMSG": if (r.parameters.startsWith("!")) { const a = he(r); this.emit("command", a); } break; case "PING": l(this, m).send("PONG " + r.parameters); break; case "001": l(this, m).send(`JOIN ${this.channel}`); break; case "JOIN": console.log(`Joined ${this.channel}`), O(this, b, 0); break; case "RECONNECT": this.disconnect(1012, "The Twitch IRC server is terminating the connection for maintenance reasons."); break; case "PART": console.error("The channel must have banned (/ban) the bot."), l(this, m).close(); break; case "NOTICE": r.parameters === "Login authentication failed" ? (console.error(`Authentication failed; left #${this.channel}`), l(this, m).send(`PART ${this.channel}`)) : r.parameters === "You don't have permission to perform that action" && (console.error(`No permission. Check if the access token is still valid. Left ${this.channel}`), l(this, m).send(`PART ${this.channel}`)); break; } });
   }, F = new WeakSet, z = function () { return l(this, A)[l(this, m).readyState]; }; function he(o) { var e, t; return { user: o.tags["display-name"], command: o.command.botCommand, message: o.command.botCommandParams || "", flags: { broadcaster: !!((e = o.tags.badges) != null && e.broadcaster), mod: !!((t = o.tags.badges) != null && t.moderator) }, extra: { userColor: o.tags.color, messageId: o.tags.id } }; } function me(o) { o.emit("command", { user: "adminUser", command: "clearList", message: "", flags: { broadcaster: !0, mod: !1 }, extra: { userColor: "#FF0000", messageId: `${H()}` } }); const e = ["red", "coral", "springGreen", "lightSeaGreen", "slateBlue", "hotpink", "violet", "orange", "darkTurquoise", "dodgerblue", "blueviolet"]; for (let t = 1; t <= 8; t++) { const s = `Username${t}`, n = e[t - 1]; for (let r = 0; r < 3; r++) { const a = { user: s, command: "taskadd", message: `test task description ${r === 2 ? "with longer text for example" : ""}`, flags: { broadcaster: !0, mod: !1 }, extra: { userColor: n, messageId: `${H()}` } }; setTimeout(() => { o.emit("command", a); }, 1e3 * t + r * 100); } setTimeout(() => { const r = { user: s, command: "taskdone", message: "1", flags: { broadcaster: !0, mod: !1 }, extra: { userColor: n, messageId: `${H()}` } }; o.emit("command", r); }, 1e3 * t + 1e4); } } function H() { return `${Math.floor(Math.random() * 1e9)}`; } const { auth: { twitch_channel: pe, twitch_oauth: fe, twitch_username: ke }, settings: { testMode: Y } } = configs, P = new ue({ username: ke, authToken: fe, channel: pe }); window.addEventListener("load", () => { let o = "userList"; Y && (console.log("Test mode enabled"), o = "testUserList"); const e = new re(o); e.render(), P.on("command", t => { const { user: s, command: n, message: r, flags: a, extra: i } = t, c = e.chatHandler(s, n, r, a, i); c.error ? console.error(c.message) : P.say(c.message, i.messageId); }), P.connect(), Y && me(P); });
})();
